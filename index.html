<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Teaching Chess Board</title>
  <style>
    :root {
      --light: #f0d9b5;
      --dark: #b58863;
      --panel: #141414;
      --accent: #4e8cff;
      --text: #f3f3f3;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      min-height: 100vh;
      font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      background: #0e0e0f;
      color: var(--text);
      display: flex;
      justify-content: center;
      padding: 20px;
    }
    .app {
      display: grid;
      grid-template-columns: auto 320px;
      gap: 18px;
      align-items: start;
    }
    .board-wrap {
      display: grid;
      grid-template-columns: 22px auto 22px;
      grid-template-rows: 22px auto 22px;
      align-items: center;
      justify-items: center;
      background: #1b1b1c;
      border: 1px solid #363638;
      border-radius: 8px;
      padding: 6px;
      box-shadow: 0 8px 30px rgba(0,0,0,.35);
    }
    #board {
      grid-column: 2;
      grid-row: 2;
      display: grid;
      grid-template-columns: repeat(8, 68px);
      grid-template-rows: repeat(8, 68px);
      border: 2px solid #333;
    }
    .coords-strip {
      display: grid;
      color: #c7c7c7;
      font-size: 12px;
      font-weight: 700;
      letter-spacing: 0.3px;
      user-select: none;
    }
    .coords-top,
    .coords-bottom {
      width: 544px;
      grid-template-columns: repeat(8, 68px);
      text-align: center;
    }
    .coords-top { grid-column: 2; grid-row: 1; }
    .coords-bottom { grid-column: 2; grid-row: 3; }
    .coords-left,
    .coords-right {
      height: 544px;
      grid-template-rows: repeat(8, 68px);
      align-items: center;
      text-align: center;
      width: 22px;
    }
    .coords-left { grid-column: 1; grid-row: 2; }
    .coords-right { grid-column: 3; grid-row: 2; }
    .sq {
      position: relative;
      width: 68px;
      height: 68px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 44px;
      cursor: pointer;
      user-select: none;
      color: #181818;
      text-shadow: 0 1px 0 rgba(255,255,255,.25);
    }
    .piece-white { color: #131313; }
    .piece-black { color: #131313; opacity: .88; }
    .light { background: var(--light); }
    .dark { background: var(--dark); }
    .selected { outline: 3px solid #55f; outline-offset: -3px; }
    .legal::after {
      content: '';
      position: absolute;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: rgba(35,35,35,.35);
    }
    .capture::after {
      content: '';
      position: absolute;
      inset: 6px;
      border: 4px solid rgba(20,20,20,.35);
      border-radius: 50%;
    }
    .check { box-shadow: inset 0 0 0 5px rgba(255,0,0,.65); }
    .panel {
      background: var(--panel);
      border: 1px solid #2b2b2b;
      padding: 14px;
      border-radius: 10px;
      display: grid;
      gap: 10px;
      width: 320px;
    }
    .panel h2, .panel h3 { margin: 0 0 2px; font-size: 18px; }
    .panel h3 { font-size: 15px; }
    .btns { display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 8px; }
    .btns.one-col { grid-template-columns: 1fr; }
    button {
      border: 1px solid #3a3a3a;
      background: #232325;
      color: var(--text);
      border-radius: 8px;
      padding: 9px 10px;
      cursor: pointer;
      font-weight: 600;
    }
    button:hover { border-color: var(--accent); }
    label { font-size: 13px; opacity: .95; font-weight: 600; }
    select,
    textarea {
      width: 100%;
      border-radius: 8px;
      border: 1px solid #3a3a3a;
      background: #111114;
      color: #fff;
      padding: 8px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      font-size: 12px;
    }
    select { font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    textarea {
      min-height: 95px;
      resize: vertical;
    }
    #lessonBox {
      min-height: 70px;
      border: 1px solid #2f2f2f;
      border-radius: 8px;
      background: #111114;
      padding: 8px;
      font-size: 13px;
      line-height: 1.35;
      white-space: pre-wrap;
    }
    #packetOutput { min-height: 85px; }
    .meta { font-size: 13px; opacity: .95; }
    .section { border-top: 1px solid #2b2b2b; padding-top: 10px; }
  </style>
</head>
<body>
  <div class="app">
    <div class="board-wrap">
      <div id="coordsTop" class="coords-strip coords-top"></div>
      <div id="coordsLeft" class="coords-strip coords-left"></div>
      <div id="board" aria-label="Chess board"></div>
      <div id="coordsRight" class="coords-strip coords-right"></div>
      <div id="coordsBottom" class="coords-strip coords-bottom"></div>
    </div>
    <aside class="panel">
      <h2>Teaching Board</h2>
      <div class="btns">
        <button id="undoBtn">Undo</button>
        <button id="flipBtn">Flip Board</button>
      </div>
      <div class="meta" id="status"></div>

      <label for="fenInput">Position (FEN)</label>
      <textarea id="fenInput" spellcheck="false"></textarea>
      <div class="btns">
        <button id="loadFenBtn">Load FEN</button>
        <button id="copyFenBtn">Copy Current FEN</button>
      </div>

      <div class="section">
        <h3>Lessons</h3>
        <label for="lessonPackSelect">Lesson Pack</label>
        <select id="lessonPackSelect"></select>
        <label for="lessonSelect">Lesson</label>
        <select id="lessonSelect"></select>
        <div class="btns">
          <button id="loadLessonBtn">Load Lesson</button>
          <button id="resetLessonBtn">Reset Lesson</button>
          <button id="showHintBtn">Show Hint</button>
          <button id="showSolutionBtn">Show Solution</button>
        </div>
        <div class="btns one-col">
          <button id="copyPacketBtn">Copy Coaching Packet</button>
        </div>
      </div>

      <label for="lessonBox">Lesson / Tips</label>
      <div id="lessonBox">No lesson loaded.</div>
      <label for="packetOutput">Coaching Packet</label>
      <textarea id="packetOutput" readonly spellcheck="false" placeholder="Packet will appear here when copied."></textarea>
    </aside>
  </div>

  <script>
    const FILES = ['a','b','c','d','e','f','g','h'];
    const START_FEN = 'rn1qkbnr/pppb1ppp/3pp3/8/2BP4/5N2/PPP2PPP/RNBQ1RK1 w kq - 0 6';
    const LESSONS_INDEX_PATH = 'lessons/index.json';
    const LEGACY_LESSONS_PATH = 'lessons/lessons.json';
    const PIECE_UNICODE = {
      K:'♔',Q:'♕',R:'♖',B:'♗',N:'♘',P:'♙',
      k:'♚',q:'♛',r:'♜',b:'♝',n:'♞',p:'♟'
    };

    const S = {
      board: createEmptyBoard(),
      turn: 'w',
      castling: { K:false, Q:false, k:false, q:false },
      ep: '-',
      halfmove: 0,
      fullmove: 1,
      flipped: false,
      history: [],
      moveLog: []
    };

    const TRAIN = {
      active: false,
      lesson: null,
      stepIndex: 0,
      lastAttempt: null,
      message: ''
    };

    let LESSONS = [];
    let LESSON_PACKS = [];
    const PACK_CACHE = new Map();
    let ACTIVE_PACK_ID = null;
    let ACTIVE_PACK_TITLE = '';
    let selection = null;
    let legalForSelection = [];

    const boardEl = document.getElementById('board');
    const statusEl = document.getElementById('status');
    const fenInputEl = document.getElementById('fenInput');
    const lessonBoxEl = document.getElementById('lessonBox');
    const packetOutputEl = document.getElementById('packetOutput');
    const lessonPackSelectEl = document.getElementById('lessonPackSelect');
    const lessonSelectEl = document.getElementById('lessonSelect');
    const coordsTopEl = document.getElementById('coordsTop');
    const coordsLeftEl = document.getElementById('coordsLeft');
    const coordsRightEl = document.getElementById('coordsRight');
    const coordsBottomEl = document.getElementById('coordsBottom');

    function escapeHtml(value) {
      return String(value)
        .replaceAll('&', '&amp;')
        .replaceAll('<', '&lt;')
        .replaceAll('>', '&gt;')
        .replaceAll('\"', '&quot;')
        .replaceAll("'", '&#39;');
    }

    function createEmptyBoard() {
      return Array.from({ length: 8 }, () => Array(8).fill(''));
    }

    function squareToCoords(square) {
      if (!square || square === '-' || square.length !== 2) return null;
      const f = FILES.indexOf(square[0]);
      const r = 8 - Number(square[1]);
      if (f < 0 || Number.isNaN(r) || r < 0 || r > 7) return null;
      return { r, c: f };
    }

    function coordsToSquare(r, c) {
      return `${FILES[c]}${8-r}`;
    }

    function pieceColor(piece) { return piece === piece.toUpperCase() ? 'w' : 'b'; }
    function moveToCoordString(m) {
      const promotion = m.promotion ? m.promotion.toUpperCase() : '';
      return `${coordsToSquare(m.from.r, m.from.c)}${coordsToSquare(m.to.r, m.to.c)}${promotion}`;
    }

    function lessonResponseForMove(coordMove) {
      if (!TRAIN.lesson || !Array.isArray(TRAIN.lesson.responses)) return '';
      const direct = TRAIN.lesson.responses.find((r) => r.ifUserMove === coordMove);
      if (direct) return direct.message;
      const fallback = TRAIN.lesson.responses.find((r) => r.ifUserMove === '*');
      return fallback ? fallback.message : '';
    }

    function normalizeConstraints(lesson) {
      const base = {
        userSide: 'both',
        lockOtherSide: false,
        restrictFromSquares: [],
        restrictPieceTypes: [],
        enforceOnlyAllowedMoves: false
      };
      return Object.assign(base, lesson.constraints || {});
    }

    function parseFEN(fen) {
      const parts = fen.trim().split(/\s+/);
      if (parts.length < 4) throw new Error('FEN needs at least 4 fields.');
      const [placement, turn, castling, ep, halfmove='0', fullmove='1'] = parts;
      const rows = placement.split('/');
      if (rows.length !== 8) throw new Error('Piece placement must have 8 ranks.');

      const board = createEmptyBoard();
      for (let r = 0; r < 8; r++) {
        let c = 0;
        for (const ch of rows[r]) {
          if (/\d/.test(ch)) c += Number(ch);
          else if ('prnbqkPRNBQK'.includes(ch)) board[r][c++] = ch;
          else throw new Error(`Invalid piece token: ${ch}`);
        }
        if (c !== 8) throw new Error(`Rank ${8-r} does not have 8 files.`);
      }

      if (!['w','b'].includes(turn)) throw new Error('Active color must be w or b.');
      if (!(castling === '-' || /^[KQkq]+$/.test(castling))) throw new Error('Invalid castling field.');
      if (!(ep === '-' || /^[a-h][36]$/.test(ep))) throw new Error('Invalid en-passant square.');

      return {
        board,
        turn,
        castling: {
          K: castling.includes('K'),
          Q: castling.includes('Q'),
          k: castling.includes('k'),
          q: castling.includes('q')
        },
        ep,
        halfmove: Number.isFinite(Number(halfmove)) ? Number(halfmove) : 0,
        fullmove: Number.isFinite(Number(fullmove)) ? Number(fullmove) : 1
      };
    }

    function boardToFEN() {
      const ranks = [];
      for (let r = 0; r < 8; r++) {
        let run = 0;
        let rank = '';
        for (let c = 0; c < 8; c++) {
          const p = S.board[r][c];
          if (!p) run++;
          else {
            if (run) { rank += run; run = 0; }
            rank += p;
          }
        }
        if (run) rank += run;
        ranks.push(rank);
      }
      const castling = ['K','Q','k','q'].filter((k) => S.castling[k]).join('') || '-';
      const ep = S.ep && S.ep !== '' ? S.ep : '-';
      return `${ranks.join('/')} ${S.turn} ${castling} ${ep} ${S.halfmove} ${S.fullmove}`;
    }

    function cloneState() {
      return JSON.parse(JSON.stringify({
        board: S.board,
        turn: S.turn,
        castling: S.castling,
        ep: S.ep,
        halfmove: S.halfmove,
        fullmove: S.fullmove,
        moveLog: S.moveLog
      }));
    }

    function restoreState(snapshot) {
      S.board = snapshot.board;
      S.turn = snapshot.turn;
      S.castling = snapshot.castling;
      S.ep = snapshot.ep;
      S.halfmove = snapshot.halfmove;
      S.fullmove = snapshot.fullmove;
      S.moveLog = snapshot.moveLog || [];
      selection = null;
      legalForSelection = [];
      render();
    }

    function inBounds(r, c) { return r >= 0 && r < 8 && c >= 0 && c < 8; }

    function kingSquare(board, color) {
      const k = color === 'w' ? 'K' : 'k';
      for (let r = 0; r < 8; r++) for (let c = 0; c < 8; c++) if (board[r][c] === k) return { r, c };
      return null;
    }

    function isSquareAttacked(board, tr, tc, byColor) {
      const pawnDir = byColor === 'w' ? -1 : 1;
      for (const dc of [-1,1]) {
        const r = tr - pawnDir;
        const c = tc + dc;
        if (inBounds(r,c)) {
          const p = board[r][c];
          if (p && pieceColor(p) === byColor && p.toLowerCase() === 'p') return true;
        }
      }
      const knightJumps = [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]];
      for (const [dr,dc] of knightJumps) {
        const r = tr + dr, c = tc + dc;
        if (!inBounds(r,c)) continue;
        const p = board[r][c];
        if (p && pieceColor(p) === byColor && p.toLowerCase() === 'n') return true;
      }
      const lines = [
        { dirs:[[-1,0],[1,0],[0,-1],[0,1]], pieces:['r','q'] },
        { dirs:[[-1,-1],[-1,1],[1,-1],[1,1]], pieces:['b','q'] }
      ];
      for (const group of lines) {
        for (const [dr,dc] of group.dirs) {
          let r = tr + dr, c = tc + dc;
          while (inBounds(r,c)) {
            const p = board[r][c];
            if (p) {
              if (pieceColor(p) === byColor && group.pieces.includes(p.toLowerCase())) return true;
              break;
            }
            r += dr;
            c += dc;
          }
        }
      }
      for (let dr = -1; dr <= 1; dr++) {
        for (let dc = -1; dc <= 1; dc++) {
          if (!dr && !dc) continue;
          const r = tr + dr, c = tc + dc;
          if (!inBounds(r,c)) continue;
          const p = board[r][c];
          if (p && pieceColor(p) === byColor && p.toLowerCase() === 'k') return true;
        }
      }
      return false;
    }

    function inCheck(board, color) {
      const king = kingSquare(board, color);
      if (!king) return false;
      return isSquareAttacked(board, king.r, king.c, color === 'w' ? 'b' : 'w');
    }

    function applyMoveOnBoard(state, m) {
      const b = state.board;
      const piece = b[m.from.r][m.from.c];
      const target = b[m.to.r][m.to.c];

      if (piece.toLowerCase() === 'p' || target) state.halfmove = 0;
      else state.halfmove += 1;

      if (piece.toLowerCase() === 'p' && m.to.c !== m.from.c && !target) {
        const capR = m.from.r;
        b[capR][m.to.c] = '';
      }

      b[m.to.r][m.to.c] = piece;
      b[m.from.r][m.from.c] = '';

      if (piece === 'K') { state.castling.K = false; state.castling.Q = false; }
      if (piece === 'k') { state.castling.k = false; state.castling.q = false; }
      if (piece === 'R' && m.from.r === 7 && m.from.c === 0) state.castling.Q = false;
      if (piece === 'R' && m.from.r === 7 && m.from.c === 7) state.castling.K = false;
      if (piece === 'r' && m.from.r === 0 && m.from.c === 0) state.castling.q = false;
      if (piece === 'r' && m.from.r === 0 && m.from.c === 7) state.castling.k = false;
      if (target === 'R' && m.to.r === 7 && m.to.c === 0) state.castling.Q = false;
      if (target === 'R' && m.to.r === 7 && m.to.c === 7) state.castling.K = false;
      if (target === 'r' && m.to.r === 0 && m.to.c === 0) state.castling.q = false;
      if (target === 'r' && m.to.r === 0 && m.to.c === 7) state.castling.k = false;

      if (piece.toLowerCase() === 'k' && Math.abs(m.to.c - m.from.c) === 2) {
        if (m.to.c === 6) {
          b[m.to.r][5] = b[m.to.r][7];
          b[m.to.r][7] = '';
        } else {
          b[m.to.r][3] = b[m.to.r][0];
          b[m.to.r][0] = '';
        }
      }

      if (piece === 'P' && m.to.r === 0) {
        const promo = m.promotion ? m.promotion.toUpperCase() : 'Q';
        b[m.to.r][m.to.c] = promo;
      }
      if (piece === 'p' && m.to.r === 7) {
        const promo = m.promotion ? m.promotion.toLowerCase() : 'q';
        b[m.to.r][m.to.c] = promo;
      }

      if (piece.toLowerCase() === 'p' && Math.abs(m.to.r - m.from.r) === 2) {
        state.ep = coordsToSquare((m.to.r + m.from.r) / 2, m.from.c);
      } else {
        state.ep = '-';
      }

      state.turn = state.turn === 'w' ? 'b' : 'w';
      if (state.turn === 'w') state.fullmove += 1;
    }

    function pseudoMovesFor(board, r, c, state) {
      const piece = board[r][c];
      if (!piece) return [];
      const color = pieceColor(piece);
      const enemy = color === 'w' ? 'b' : 'w';
      const lower = piece.toLowerCase();
      const moves = [];

      if (lower === 'p') {
        const dir = color === 'w' ? -1 : 1;
        const home = color === 'w' ? 6 : 1;
        const one = r + dir;
        if (inBounds(one, c) && !board[one][c]) {
          moves.push({ from:{r,c}, to:{r:one,c} });
          const two = r + dir * 2;
          if (r === home && !board[two][c]) moves.push({ from:{r,c}, to:{r:two,c} });
        }
        for (const dc of [-1,1]) {
          const tr = r + dir, tc = c + dc;
          if (!inBounds(tr,tc)) continue;
          const t = board[tr][tc];
          if (t && pieceColor(t) === enemy) moves.push({ from:{r,c}, to:{r:tr,c:tc} });
        }
        const epC = squareToCoords(state.ep);
        if (epC && epC.r === r + dir && Math.abs(epC.c - c) === 1) {
          moves.push({ from:{r,c}, to:{r:epC.r,c:epC.c} });
        }
      }

      if (lower === 'n') {
        const jumps = [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]];
        for (const [dr,dc] of jumps) {
          const tr = r + dr, tc = c + dc;
          if (!inBounds(tr,tc)) continue;
          const t = board[tr][tc];
          if (!t || pieceColor(t) !== color) moves.push({ from:{r,c}, to:{r:tr,c:tc} });
        }
      }

      if (['b','r','q'].includes(lower)) {
        const dirs = [];
        if (['b','q'].includes(lower)) dirs.push([-1,-1],[-1,1],[1,-1],[1,1]);
        if (['r','q'].includes(lower)) dirs.push([-1,0],[1,0],[0,-1],[0,1]);
        for (const [dr,dc] of dirs) {
          let tr = r + dr, tc = c + dc;
          while (inBounds(tr,tc)) {
            const t = board[tr][tc];
            if (!t) moves.push({ from:{r,c}, to:{r:tr,c:tc} });
            else {
              if (pieceColor(t) !== color) moves.push({ from:{r,c}, to:{r:tr,c:tc} });
              break;
            }
            tr += dr;
            tc += dc;
          }
        }
      }

      if (lower === 'k') {
        for (let dr = -1; dr <= 1; dr++) {
          for (let dc = -1; dc <= 1; dc++) {
            if (!dr && !dc) continue;
            const tr = r + dr, tc = c + dc;
            if (!inBounds(tr,tc)) continue;
            const t = board[tr][tc];
            if (!t || pieceColor(t) !== color) moves.push({ from:{r,c}, to:{r:tr,c:tc} });
          }
        }

        const homeRank = color === 'w' ? 7 : 0;
        const enemyColor = color === 'w' ? 'b' : 'w';
        if (r === homeRank && c === 4 && !inCheck(board, color)) {
          const kFlag = color === 'w' ? 'K' : 'k';
          const qFlag = color === 'w' ? 'Q' : 'q';
          if (state.castling[kFlag] && !board[homeRank][5] && !board[homeRank][6]) {
            if (!isSquareAttacked(board, homeRank, 5, enemyColor) && !isSquareAttacked(board, homeRank, 6, enemyColor)) {
              moves.push({ from:{r,c}, to:{r:homeRank,c:6} });
            }
          }
          if (state.castling[qFlag] && !board[homeRank][1] && !board[homeRank][2] && !board[homeRank][3]) {
            if (!isSquareAttacked(board, homeRank, 3, enemyColor) && !isSquareAttacked(board, homeRank, 2, enemyColor)) {
              moves.push({ from:{r,c}, to:{r:homeRank,c:2} });
            }
          }
        }
      }
      return moves;
    }

    function filterMovesByLesson(moves) {
      if (!TRAIN.active || !TRAIN.lesson) return moves;
      const constraints = normalizeConstraints(TRAIN.lesson);
      const fromSet = new Set((constraints.restrictFromSquares || []).map((sq) => sq.toLowerCase()));
      const typeSet = new Set((constraints.restrictPieceTypes || []).map((p) => p.toUpperCase()));
      const expectedMove = TRAIN.lesson.solution && TRAIN.lesson.solution.moves ? TRAIN.lesson.solution.moves[TRAIN.stepIndex] : null;

      return moves.filter((m) => {
        const moverPiece = S.board[m.from.r][m.from.c];
        const moverColor = pieceColor(moverPiece);
        const fromSq = coordsToSquare(m.from.r, m.from.c).toLowerCase();
        const pieceType = moverPiece.toUpperCase();
        const coordMove = moveToCoordString(m);

        if (constraints.lockOtherSide) {
          if (constraints.userSide === 'w' && moverColor !== 'w') return false;
          if (constraints.userSide === 'b' && moverColor !== 'b') return false;
        }
        if (fromSet.size && !fromSet.has(fromSq)) return false;
        if (typeSet.size && !typeSet.has(pieceType)) return false;
        if (constraints.enforceOnlyAllowedMoves && expectedMove) {
          return coordMove.toLowerCase() === expectedMove.toLowerCase();
        }
        return true;
      });
    }

    function legalMovesFor(r, c) {
      const piece = S.board[r][c];
      if (!piece || pieceColor(piece) !== S.turn) return [];
      const pseudos = pseudoMovesFor(S.board, r, c, S);
      const legal = pseudos.filter((m) => {
        const test = JSON.parse(JSON.stringify({
          board: S.board,
          turn: S.turn,
          castling: S.castling,
          ep: S.ep,
          halfmove: S.halfmove,
          fullmove: S.fullmove
        }));
        applyMoveOnBoard(test, m);
        return !inCheck(test.board, S.turn);
      });
      return filterMovesByLesson(legal);
    }

    function validateTurnForLesson() {
      if (!TRAIN.active || !TRAIN.lesson) return true;
      const constraints = normalizeConstraints(TRAIN.lesson);
      if (!constraints.lockOtherSide) return true;
      if (constraints.userSide === 'both') return true;
      return S.turn === constraints.userSide;
    }

    function makeMove(m, { bypassLessonValidation = false } = {}) {
      const coordMove = moveToCoordString(m);
      if (!bypassLessonValidation && TRAIN.active && TRAIN.lesson) {
        TRAIN.lastAttempt = coordMove;
        const constraints = normalizeConstraints(TRAIN.lesson);
        const solutionMoves = TRAIN.lesson.solution && TRAIN.lesson.solution.moves ? TRAIN.lesson.solution.moves : [];
        const expectedMove = solutionMoves[TRAIN.stepIndex];
        const responseMessage = lessonResponseForMove(coordMove);
        const matchesExpected = expectedMove && coordMove.toLowerCase() === expectedMove.toLowerCase();

        if (constraints.enforceOnlyAllowedMoves && expectedMove && !matchesExpected) {
          TRAIN.message = responseMessage || 'Not quite. This lesson is in strict mode, so only the target move is allowed.';
          updateLessonBox();
          return false;
        }

        if (expectedMove) {
          if (matchesExpected) {
            TRAIN.stepIndex += 1;
            if (TRAIN.stepIndex >= solutionMoves.length) {
              TRAIN.message = `${responseMessage || 'Correct move!'} Lesson complete.`;
            } else {
              TRAIN.message = responseMessage || 'Correct. Keep going!';
            }
          } else {
            TRAIN.message = responseMessage || 'Move played. Compare it with the lesson goal and try improving it.';
          }
        } else {
          TRAIN.message = responseMessage || 'Move played.';
        }
      }

      S.history.push({
        snapshot: cloneState(),
        lessonStep: TRAIN.stepIndex,
        lessonLastAttempt: TRAIN.lastAttempt,
        lessonMessage: TRAIN.message
      });
      applyMoveOnBoard(S, m);
      const prefix = S.turn === 'b' ? '' : '...';
      S.moveLog.push(`${prefix}${coordMove}`);
      selection = null;
      legalForSelection = [];
      updateLessonBox();
      render();
      return true;
    }

    function handleSquareClick(r, c) {
      const piece = S.board[r][c];
      if (!validateTurnForLesson()) {
        TRAIN.message = 'This lesson restricts you to the other side.';
        updateLessonBox();
        return;
      }

      if (selection) {
        const found = legalForSelection.find((m) => m.to.r === r && m.to.c === c);
        if (found) {
          makeMove(found);
          return;
        }
      }
      if (piece && pieceColor(piece) === S.turn) {
        selection = { r, c };
        legalForSelection = legalMovesFor(r, c);
      } else {
        selection = null;
        legalForSelection = [];
      }
      render();
    }

    function loadFEN(fenString) {
      try {
        const trimmed = fenString.trim();
        if (!trimmed) throw new Error('FEN is empty.');
        const parts = trimmed.split(/\s+/);
        let adjusted = trimmed;
        if (parts.length === 4) adjusted = `${trimmed} 0 1`;
        else if (parts.length < 4) throw new Error('Please provide at least 4 FEN fields.');

        const parsed = parseFEN(adjusted);
        S.board = parsed.board;
        S.turn = parsed.turn;
        S.castling = parsed.castling;
        S.ep = parsed.ep;
        S.halfmove = parsed.halfmove;
        S.fullmove = parsed.fullmove;
        S.history = [];
        S.moveLog = [];
        selection = null;
        legalForSelection = [];
        render();
      } catch (err) {
        alert(`Could not load FEN: ${err.message}`);
      }
    }

    async function copyCurrentFEN() {
      const fen = boardToFEN();
      fenInputEl.value = fen;
      try {
        if (navigator.clipboard && navigator.clipboard.writeText) {
          await navigator.clipboard.writeText(fen);
        }
      } catch (_) {
        // no-op
      }
    }

    function updateLessonBox(extra = '') {
      const loadedPack = ACTIVE_PACK_ID
        ? `Loaded pack: ${ACTIVE_PACK_TITLE || ACTIVE_PACK_ID} (${LESSONS.length} lessons)`
        : 'Loaded pack: none';

      if (!TRAIN.active || !TRAIN.lesson) {
        lessonBoxEl.textContent = [
          loadedPack,
          extra || 'No lesson loaded.'
        ].filter(Boolean).join('\n\n');
        return;
      }
      const lesson = TRAIN.lesson;
      const tips = Array.isArray(lesson.tips) && lesson.tips.length ? `Tips:\n- ${lesson.tips.join('\n- ')}` : '';
      const progressTotal = lesson.solution && lesson.solution.moves ? lesson.solution.moves.length : 0;
      const lessonLine = progressTotal
        ? `Lesson: ${lesson.title} (step ${Math.min(TRAIN.stepIndex + 1, progressTotal)}/${progressTotal})`
        : `Lesson: ${lesson.title}`;
      const progress = progressTotal ? `Progress: ${TRAIN.stepIndex}/${progressTotal}` : 'Progress: free play';
      const parts = [
        loadedPack,
        lessonLine,
        `Goal: ${lesson.goal}`,
        tips,
        progress,
        TRAIN.message ? `Message: ${TRAIN.message}` : '',
        extra
      ].filter(Boolean);
      lessonBoxEl.textContent = parts.join('\n\n');
    }

    function renderPackSelect() {
      if (!LESSON_PACKS.length) {
        lessonPackSelectEl.innerHTML = '<option value="">No lesson packs found</option>';
        return;
      }
      lessonPackSelectEl.innerHTML = LESSON_PACKS
        .map((pack) => `<option value="${escapeHtml(pack.id)}">${escapeHtml(pack.title)}</option>`)
        .join('');
      if (ACTIVE_PACK_ID) lessonPackSelectEl.value = ACTIVE_PACK_ID;
    }

    function renderLessonSelect() {
      if (!LESSONS.length) {
        lessonSelectEl.innerHTML = '<option value="">No lessons found</option>';
        return;
      }
      lessonSelectEl.innerHTML = LESSONS
        .map((lesson) => `<option value="${escapeHtml(lesson.id)}">${escapeHtml(lesson.title)}</option>`)
        .join('');
    }

    async function fetchJson(path) {
      const res = await fetch(`${path}?v=${Date.now()}`);
      if (!res.ok) throw new Error(`Could not fetch ${path} (${res.status}).`);
      return res.json();
    }

    async function loadPackById(packId) {
      const pack = LESSON_PACKS.find((entry) => entry.id === packId);
      if (!pack) throw new Error(`Unknown lesson pack: ${packId}`);

      if (!PACK_CACHE.has(pack.id)) {
        const packPath = pack.file.includes('/') ? pack.file : `lessons/${pack.file}`;
        const data = await fetchJson(packPath);
        PACK_CACHE.set(pack.id, Array.isArray(data) ? data : []);
      }

      LESSONS = PACK_CACHE.get(pack.id);
      ACTIVE_PACK_ID = pack.id;
      ACTIVE_PACK_TITLE = pack.title;
      renderPackSelect();
      renderLessonSelect();
    }

    async function loadLegacyLessonsFallback() {
      const data = await fetchJson(LEGACY_LESSONS_PATH);
      LESSON_PACKS = [{ id: 'legacy_lessons', title: 'All Lessons (legacy)', file: LEGACY_LESSONS_PATH }];
      PACK_CACHE.set('legacy_lessons', Array.isArray(data) ? data : []);
      await loadPackById('legacy_lessons');
    }

    async function loadLessonsData() {
      try {
        const data = await fetchJson(LESSONS_INDEX_PATH);
        const packs = Array.isArray(data) ? data : [];
        LESSON_PACKS = packs
          .filter((entry) => entry && entry.id && entry.title && entry.file)
          .map((entry) => ({ id: entry.id, title: entry.title, file: entry.file }));

        if (!LESSON_PACKS.length) throw new Error('Lesson index is empty.');
        await loadPackById(LESSON_PACKS[0].id);
      } catch (_) {
        await loadLegacyLessonsFallback();
      }

      renderPackSelect();
      renderLessonSelect();
    }

    function findSelectedLesson() {
      const id = lessonSelectEl.value;
      return LESSONS.find((lesson) => lesson.id === id) || null;
    }

    function resetLessonStateMeta() {
      TRAIN.stepIndex = 0;
      TRAIN.lastAttempt = null;
      TRAIN.message = '';
    }

    function loadLesson() {
      const lesson = findSelectedLesson();
      if (!lesson) return;
      TRAIN.active = true;
      TRAIN.lesson = lesson;
      resetLessonStateMeta();
      loadFEN(lesson.fen);
      if (lesson.sideToMove && lesson.sideToMove !== S.turn) {
        TRAIN.message = `Warning: lesson sideToMove is ${lesson.sideToMove} but FEN has ${S.turn}.`;
      }
      selection = null;
      legalForSelection = [];
      updateLessonBox();
      render();
    }

    function resetCurrentLesson() {
      if (!TRAIN.active || !TRAIN.lesson) return;
      resetLessonStateMeta();
      loadFEN(TRAIN.lesson.fen);
      updateLessonBox('Lesson reset to starting position.');
      render();
    }

    function showHint() {
      if (!TRAIN.active || !TRAIN.lesson) {
        updateLessonBox('Load a lesson first.');
        return;
      }
      updateLessonBox(`Hint: ${TRAIN.lesson.hint || 'No hint provided for this lesson.'}`);
    }

    function showSolution() {
      if (!TRAIN.active || !TRAIN.lesson) {
        updateLessonBox('Load a lesson first.');
        return;
      }
      const sol = TRAIN.lesson.solution || {};
      const line = Array.isArray(sol.san) && sol.san.length ? sol.san.join(' ') : (sol.moves || []).join(' ');
      const explanation = Array.isArray(sol.explanation) && sol.explanation.length ? `Explanation:\n- ${sol.explanation.join('\n- ')}` : '';
      updateLessonBox(`Solution: ${line || 'No solution line supplied.'}\n${explanation}`);
    }

    function exitLessonMode(message = '') {
      TRAIN.active = false;
      TRAIN.lesson = null;
      TRAIN.stepIndex = 0;
      TRAIN.lastAttempt = null;
      TRAIN.message = '';
      updateLessonBox(message || 'No lesson loaded.');
    }

    function buildCoachingPacket() {
      return {
        fen: boardToFEN(),
        turn: S.turn,
        history: [...S.moveLog],
        lesson: TRAIN.active && TRAIN.lesson ? TRAIN.lesson.id : null,
        lessonPackId: ACTIVE_PACK_ID,
        lessonPackTitle: ACTIVE_PACK_TITLE,
        lessonStep: TRAIN.active ? TRAIN.stepIndex : null,
        constraints: TRAIN.active && TRAIN.lesson ? normalizeConstraints(TRAIN.lesson) : null,
        lastAttempt: TRAIN.lastAttempt,
        message: TRAIN.message,
        lessonMode: TRAIN.active
      };
    }

    async function copyCoachingPacket() {
      const packet = buildCoachingPacket();
      const payload = JSON.stringify(packet);
      packetOutputEl.value = payload;
      try {
        if (navigator.clipboard && navigator.clipboard.writeText) {
          await navigator.clipboard.writeText(payload);
        }
      } catch (_) {
        // textarea fallback is already populated.
      }
      TRAIN.message = 'Coaching packet copied (and shown below).';
      updateLessonBox();
    }

    function renderCoordinateFrame() {
      const files = S.flipped ? [...FILES].reverse() : [...FILES];
      const ranks = S.flipped ? ['1','2','3','4','5','6','7','8'] : ['8','7','6','5','4','3','2','1'];
      coordsTopEl.innerHTML = files.map((f) => `<span>${f}</span>`).join('');
      coordsBottomEl.innerHTML = files.map((f) => `<span>${f}</span>`).join('');
      coordsLeftEl.innerHTML = ranks.map((r) => `<span>${r}</span>`).join('');
      coordsRightEl.innerHTML = ranks.map((r) => `<span>${r}</span>`).join('');
    }

    function render() {
      boardEl.innerHTML = '';
      renderCoordinateFrame();
      const checkSq = kingSquare(S.board, S.turn);
      const inChk = inCheck(S.board, S.turn);
      for (let vr = 0; vr < 8; vr++) {
        for (let vc = 0; vc < 8; vc++) {
          const r = S.flipped ? 7 - vr : vr;
          const c = S.flipped ? 7 - vc : vc;
          const sq = document.createElement('div');
          const isLight = (vr + vc) % 2 === 0;
          sq.className = `sq ${isLight ? 'light' : 'dark'}`;
          const p = S.board[r][c];
          if (p) {
            sq.textContent = PIECE_UNICODE[p] || p;
            sq.classList.add(pieceColor(p) === 'w' ? 'piece-white' : 'piece-black');
          }

          if (selection && selection.r === r && selection.c === c) sq.classList.add('selected');
          const legal = legalForSelection.find((m) => m.to.r === r && m.to.c === c);
          if (legal) {
            sq.classList.add('legal');
            if (S.board[r][c]) sq.classList.add('capture');
          }
          if (inChk && checkSq && checkSq.r === r && checkSq.c === c) sq.classList.add('check');

          sq.addEventListener('click', () => handleSquareClick(r, c));
          boardEl.appendChild(sq);
        }
      }

      const castling = ['K','Q','k','q'].filter((k) => S.castling[k]).join('') || '-';
      const mode = TRAIN.active && TRAIN.lesson ? ` • Lesson: ${TRAIN.lesson.id}` : '';
      statusEl.textContent = `${S.turn === 'w' ? 'White' : 'Black'} to move • Castling: ${castling} • EP: ${S.ep}${mode}`;
      fenInputEl.value = boardToFEN();
    }

    document.getElementById('undoBtn').addEventListener('click', () => {
      if (!S.history.length) return;
      const prev = S.history.pop();
      restoreState(prev.snapshot);
      TRAIN.stepIndex = prev.lessonStep;
      TRAIN.lastAttempt = prev.lessonLastAttempt;
      TRAIN.message = prev.lessonMessage;
      updateLessonBox('Undid last move.');
    });

    document.getElementById('flipBtn').addEventListener('click', () => {
      S.flipped = !S.flipped;
      render();
    });

    document.getElementById('loadFenBtn').addEventListener('click', () => {
      loadFEN(fenInputEl.value);
      exitLessonMode('Lesson mode exited after manual FEN load.');
    });
    document.getElementById('copyFenBtn').addEventListener('click', copyCurrentFEN);
    lessonPackSelectEl.addEventListener('change', async () => {
      if (!lessonPackSelectEl.value) return;
      try {
        await loadPackById(lessonPackSelectEl.value);
        exitLessonMode('Pick a lesson and click Load Lesson.');
      } catch (err) {
        updateLessonBox(`Could not load selected lesson pack: ${err.message}`);
      }
    });
    document.getElementById('loadLessonBtn').addEventListener('click', loadLesson);
    document.getElementById('resetLessonBtn').addEventListener('click', resetCurrentLesson);
    document.getElementById('showHintBtn').addEventListener('click', showHint);
    document.getElementById('showSolutionBtn').addEventListener('click', showSolution);
    document.getElementById('copyPacketBtn').addEventListener('click', copyCoachingPacket);

    loadFEN(START_FEN);
    updateLessonBox('Loading lessons...');
    loadLessonsData()
      .then(() => updateLessonBox('No lesson loaded. Pick a lesson and click Load Lesson.'))
      .catch((err) => {
        lessonPackSelectEl.innerHTML = '<option value="">No lesson packs available</option>';
        lessonSelectEl.innerHTML = '<option value="">No lessons available</option>';
        updateLessonBox(`Could not load lessons. Please check lessons/index.json or lessons/lessons.json. (${err.message})`);
      });
  </script>
</body>
</html>
